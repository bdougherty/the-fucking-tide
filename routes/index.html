<svelte:head>
	<title>The Fucking Tide</title>
</svelte:head>

{#if findingLocation}
	<LoadingMessage>Finding your fucking location</LoadingMessage>
{:elseif locationError}
	<Search on:search="handleSearch(event)" />
{:elseif checkingTide}
	<LoadingMessage>Checking the fucking tide</LoadingMessage>
{:else}
	<Message station={stationName} progress={tideProgress} rising={nextTide.type === 'high'} />
{/if}

<script>
	import LoadingMessage from '../components/LoadingMessage.html';
	import Message from '../components/Message.html';
	import Search from '../components/Search.html';

	export default {
		components: {
			LoadingMessage,
			Message,
			Search
		},
		data() {
			return {
				time: new Date(),
				findingLocation: true,
				locationError: false,
				checkingTide: false,
				location: null,
				stationName: null,
				predictions: []
			};
		},
		oncreate() {
			if (this.interval) {
				clearInterval(this.interval);
			}

			this.interval = setInterval(() => {
				console.log('updating time');
				this.set({ time: new Date() });
			}, 1000 * 60);
		},
		ondestroy() {
			clearInterval(this.interval);
		},
		onstate({ changed, current, previous }) {
			if (!previous && !current.location) {
				this.set({
					findingLocation: true
				});

				this.getGeolocation()
					.then((location) => {
						this.set({
							findingLocation: false,
							checkingTide: true,
							location
						});
					})
					.catch((error) => {
						this.set({
							findingLocation: false,
							locationError: true
						});
					});

				return;
			}

			if (changed.location && current.location) {
				const { lat, lon } = current.location;

				this.set({
					findingLocation: false,
					checkingTide: true
				});

				this.fetchPredictions({ lat, lon }).then(({ name, predictions }) => {
					this.set({
						checkingTide: false,
						stationName: name,
						predictions
					});
				});

				return;
			}
		},
		computed: {
			nextTide: ({ predictions }) => {
				if (predictions.length === 0) {
					return null;
				}

				return predictions.find((prediction) => {
					return new Date(prediction.time) > new Date();
				});
			},
			previousTide: ({ nextTide, predictions }) => {
				if (predictions.length === 0) {
					return null;
				}

				const index = predictions.indexOf(nextTide);
				return predictions[index - 1];
			},
			tideProgress: ({ time, previousTide, nextTide }) => {
				if (!previousTide || !nextTide) {
					return -1;
				}

				const timeSincePreviousTide = time - new Date(previousTide.time);
				const tideDifference = new Date(nextTide.time) - new Date(previousTide.time);
				const progress = timeSincePreviousTide / tideDifference;

				return progress;
			}
		},
		methods: {
			handleSearch(event) {
				this.set({
					locationError: false,
					findingLocation: true
				});

				return this.geocode(event.searchText).then(({ lat, lon }) => {
					this.set({
						location: { lat, lon }
					});
				});
			},
			getGeolocation() {
				return new Promise((resolve, reject) => {
					const success = ({ coords }) => {
						resolve({
							lat: coords.latitude,
							lon: coords.longitude
						});
					};

					if (!navigator.geolocation) {
						reject(new Error('Geolocation not available in this browser.'));
					}

					navigator.geolocation.getCurrentPosition(success, reject)
				});
			},
			makeGraphQLRequest(query, variables) {
				return fetch('https://api.tides.app/graphql', {
					method: 'POST',
					headers: {
						'content-type': 'application/json'
					},
					body: JSON.stringify({
						query: query.replace(/\s+/g, ' ').replace(/\s?([{}():])\s?/g, '$1').trim(),
						variables
					})
				}).then((response) => {
					return response.json();
				}).then((json) => {
					if (json.errors) {
						console.info(json.errors);
						throw new Error('there was an error');
					}

					return json.data;
				});
			},
			geocode(search) {
				const query = `
					query($search: String!) {
						geocode(query: $search) {
							lat
							lon
						}
					}
				`;

				return this.makeGraphQLRequest(query, { search }).then((data) => {
					return data.geocode[0];
				});
			},
			fetchPredictions({ lat, lon }) {
				const query = `
					query($coordinate: Coordinate!) {
						tideStations(coordinate: $coordinate, limit: 1) {
							name
							distance
							predictions {
								type
								time
							}
						}
					}
				`;

				return this.makeGraphQLRequest(query, {
					coordinate: {
						lat,
						lon
					}
				}).then((data) => {
					return data.tideStations[0];
				});
			}
		}
	};
</script>
